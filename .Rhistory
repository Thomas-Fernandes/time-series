B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- 10000
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- 10000
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- 1000000
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- 2 * pi /20
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- 2 * pi /40
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- pi
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- pi/20
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectories <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectories[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
# Tracer les trajectoires
plot(t, trajectories[, 1], type = 'l', col = 'red', ylim = range(trajectories),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectories[, 2], col = 'green')
lines(t, trajectories[, 3], col = 'blue')
n <- 200
omega <- pi/20
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'red', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectoires[, 2], col = 'green')
lines(t, trajectoires[, 3], col = 'blue')
n <- 200
omega <- pi/20
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
View(trajectoires)
View(trajectories)
# Fonction de simulation personnalisée
simulate_process <- function(n) {
epsilon <- rnorm(n)
X <- rep(0, n)
delta2_X <- rep(0, n)
X[1] <- rnorm(1)
X[2] <- rnorm(1)
X[3] <- rnorm(1)
for (t in 4:n) {
X[t] <- 2*X[t-1] - X[t-2] + epsilon[t]
delta2_X[t] <- X[t-1] - 2*X[t-2] + X[t-3] + epsilon[t] - epsilon[t-1]
}
return(delta2_X)
}
# Génération des trajectoires
n = 200
trajectory1 <- simulate_process(n)
trajectory2 <- simulate_process(n)
trajectory3 <- simulate_process(n)
# Tracé des trajectoires
plot(trajectory1, type="l", col="black", main="Trajectoires du processus différencié à l'ordre 2", xlab="Temps", ylab="Valeurs")
lines(trajectory2, col="limegreen")
lines(trajectory3, col="lightblue")
# Fonction de simulation personnalisée
simulate_process <- function(n) {
epsilon <- rnorm(n)
X <- rep(0, n)
delta2_X <- rep(0, n)
X[1] <- rnorm(1)
X[2] <- rnorm(1)
X[3] <- rnorm(1)
for (t in 4:n) {
X[t] <- 2*X[t-1] - X[t-2] + epsilon[t]
delta2_X[t] <- X[t-1] - 2*X[t-2] + X[t-3] + epsilon[t] - epsilon[t-1]
}
return(delta2_X)
}
# Génération des trajectoires
n = 200
trajectory1 <- simulate_process(n)
trajectory2 <- simulate_process(n)
trajectory3 <- simulate_process(n)
# Tracé des trajectoires
plot(trajectory1, type="l", col="black", main="Trajectoires du processus différencié à l'ordre 2", xlab="Temps", ylab="Valeurs")
lines(trajectory2, col="limegreen")
lines(trajectory3, col="lightblue")
# Fonction de simulation personnalisée
simulate_process <- function(n) {
epsilon <- rnorm(n)
X <- rep(0, n)
delta2_X <- rep(0, n)
X[1] <- rnorm(1)
X[2] <- rnorm(1)
X[3] <- rnorm(1)
for (t in 4:n) {
X[t] <- 2*X[t-1] - X[t-2] + epsilon[t]
delta2_X[t] <- X[t-1] - 2*X[t-2] + X[t-3] + epsilon[t] - epsilon[t-1]
}
return(delta2_X)
}
# Génération des trajectoires
n = 2000
trajectory1 <- simulate_process(n)
trajectory2 <- simulate_process(n)
trajectory3 <- simulate_process(n)
# Tracé des trajectoires
plot(trajectory1, type="l", col="black", main="Trajectoires du processus différencié à l'ordre 2", xlab="Temps", ylab="Valeurs")
lines(trajectory2, col="limegreen")
lines(trajectory3, col="lightblue")
adf.test(trajectory1)
simulate_process <- function(n) {
epsilon <- rnorm(n)
X <- rep(0, n)
delta2_X <- rep(0, n)
X[1] <- rnorm(1)
X[2] <- rnorm(1)
X[3] <- rnorm(1)
for (t in 4:n) {
X[t] <- 2*X[t-1] - X[t-2] + epsilon[t]
delta2_X[t] <- X[t-1] - 2*X[t-2] + X[t-3] + epsilon[t] - epsilon[t-1]
}
return(delta2_X)
}
n = 200
trajectory1 <- simulate_process(n)
trajectory2 <- simulate_process(n)
trajectory3 <- simulate_process(n)
plot(trajectory1, type="l", col="black", main="Trajectoires du processus différencié à l'ordre 2", xlab="Temps", ylab="Valeurs")
lines(trajectory2, col="limegreen")
lines(trajectory3, col="lightblue")
# Charger le package nécessaire
library(stats)
# Définir les paramètres du modèle ARMA
n <- 100 # nombre de points de données à simuler
ar_coef <- 0.25 # coefficient AR
ma_coef <- -0.25 # coefficient MA (notez le signe négatif)
# Simuler le processus ARMA
set.seed(123) # pour la reproductibilité
simulated_data <- arima.sim(n = n, list(ar = ar_coef, ma = ma_coef))
# Tracer le processus simulé
plot(simulated_data, main="Simulated ARMA(1,1) Process", ylab="Value", xlab="Time")
b1 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
set.seed(123)
e1 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
e2 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
e3 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
plot(b1, type="l", col="black", main="Trajectoires MA(1)", xlab = "Temps", ylab = "Valeurs")
lines(b2, col="limegreen")
set.seed(123)
e1 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
e2 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
e3 <- arima.sim(model = list(ma = -0.25, ar = 0.25), n = 200)
plot(e1, type="l", col="black", main="Trajectoires MA(1)", xlab = "Temps", ylab = "Valeurs")
lines(e2, col="limegreen")
lines(e3, col="lightblue")
gc()
n <- 200
omega <- pi/20
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
c <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
n <- 200
omega <- pi/20
set.seed(1)
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Three Trajectories of X_t')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/20
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(1)
n <- 200
omega <- pi/20
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/40
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/30
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/4
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/10
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/20
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/30
A <- rnorm(3)
B <- rnorm(3)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
e1 <- arima.sim(model = list(ma = 0.25, ar = 0.25), n = 200)
e2 <- arima.sim(model = list(ma = 0.25, ar = 0.25), n = 200)
e3 <- arima.sim(model = list(ma = 0.25, ar = 0.25), n = 200)
plot(e1, type="l", col="black", main="Trajectoires MA(1)", xlab = "Temps", ylab = "Valeurs")
lines(e2, col="limegreen")
lines(e3, col="lightblue")
acf(A)
pacf(A)
acf(B)
set.seed(123)
n <- 200
omega <- pi/30
A <- rnorm(10)
B <- rnorm(10)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/30
A <- rnorm(10)
B <- rnorm(10)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
A <- rnorm(10)
acf(A)
set.seed(123)
n <- 200
omega <- pi/30
A <- rnorm(n)
B <- rnorm(n)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
set.seed(123)
n <- 200
omega <- pi/30
A <- rnorm(n)
B <- rnorm(n)
t <- 1:n
trajectoires <- matrix(0, nrow = n, ncol = 3)
for (i in 1:3) {
trajectoires[, i] <- A[i] * cos(omega * t) + B[i] * sin(omega * t)
}
plot(t, trajectoires[, 1], type = 'l', col = 'black', ylim = range(trajectoires),
xlab = 'Time', ylab = 'X_t', main = 'Trajectoires')
lines(t, trajectoires[, 2], col = 'limegreen')
lines(t, trajectoires[, 3], col = 'lightblue')
acf(A)
pacf(A)
white_noise <- rnorm(100, mean = 0, sd = 1)
# Plot the white noise series
plot.ts(white_noise, main="White Noise Series", ylab="Value")
Acf(white_noise, main="ACF of White Noise Series")
Pacf(white_noise)
library(forecast)
orders <- expand.grid(ar = 0:4, ma = 0:6)[-1, ]
models <- list()
for (i in seq(nrow(orders))) {
models[[i]] <- Arima(Zt, order = c(orders[i, "ar"], 0, orders[i, "ma"]))
}
library(forecast)
orders <- expand.grid(ar = 0:4, ma = 0:6)[-1, ]
models <- list()
for (i in seq(nrow(orders))) {
models[[i]] <- Arima(Zt, order = c(orders[i, "ar"], 0, orders[i, "ma"]))
}
library(forecast)
orders <- expand.grid(ar = 0:4, ma = 0:6)[-1, ]
models <- list()
for (i in seq(nrow(orders))) {
models[[i]] <- Arima(Zt, order = c(orders[i, "ar"], 0, orders[i, "ma"]))
}
library(forecast)
orders <- expand.grid(ar = 0:4, ma = 0:6)[-1, ]
# Fit an ARIMA model for each combination
models <- list()
for (i in seq(nrow(orders))) {
models[[i]] <- Arima(Zt, order = c(orders[i, "ar"], 0, orders[i, "ma"]))
}
